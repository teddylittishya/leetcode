# -*- coding: utf-8 -*-
"""334.Increasing triplet subsequence.ipynb

Automatically generated by Colab.

# 1. Brute force approach
Check all possible triplets using nested loops:
"""

class Solution:
    def increasingTriplet(self, nums: List[int]) -> bool:
        n = len(nums)
        for i in range(n):
            for j in range(i+1, n):
                for k in range(j+1, n):
                    if nums[i] < nums[j] < nums[k]:
                        return True
        return False

# Time complexity: O(n^3)
# Space complexity: O(1)

"""# 2. Dynamic Programming (LIS Approach)

Track the Longest Increasing Subsequence (LIS) using dynamic programming:
"""

class Solution:
    def increasingTriplet(self, nums: List[int]) -> bool:
        n = len(nums)
        if n < 3:
            return False
        # DP approach: use an array to store the length of LIS ending at each index
        dp = [1] * n
        for i in range(1, n):
            for j in range(i):
                if nums[j] < nums[i]:
                    dp[i] = max(dp[i], dp[j] + 1)
                    if dp[i] >= 3:
                        return True
        return False

# Time complexity: O(n^2)
# Space complexity: O(n)
# Faster than brute force but still inefficient for large arrays.

"""# 3. Min-Left and Max-Right Arrays

Precompute minimums to the left and maximums to the right of each element:
"""

class Solution:
    def increasingTriplet(self, nums: List[int]) -> bool:
        n = len(nums)
        if n < 3:
            return False
        min_left = [float('inf')] * n
        max_right = [float('-inf')] * n

        for i in range(1, n):
            min_left[i] = min(min_left[i-1], nums[i-1])

        for i in range(n-2, -1, -1):
            max_right[i] = max(max_right[i+1], nums[i+1])

        for i in range(n):
            if min_left[i] < nums[i] < max_right[i]:
                return True
        return False

# Time Complexity: O(n)

# Space Complexity: O(n)
# Efficient linear time approach using auxiliary arrays.

"""# 4. Optimal Greedy Approach
Track the smallest (first) and second-smallest (second) elements:

"""

class Solution:
    def increasingTriplet(self, nums: List[int]) -> bool:
        first = second = float('inf')
        for n in nums:
            if n <= first:
                first = n
            elif n <= second:
                second = n
            else:
                return True
        return False

# Time Complexity: O(n)
# Space Complexity: O(1)
# Most efficient solution with constant space.

"""
Brute Force: Simplest but impractical for large inputs.

Dynamic Programming: Balances simplicity and efficiency for moderate-sized arrays.

Min/Max Arrays: Linear time with linear space, useful for structured analysis.

Greedy Approach: Optimal O(n) time and O(1) space, ideal for large datasets."""